# [Musical.ly](https://www.nowcoder.com/discuss/79787?type=2&order=1&pos=5&page=1)

## 索引
- [reflect的DeepEqual方法对比逻辑](#reflect的DeepEqual方法对比逻辑)
- [golang的map实现](#golang的map实现)
- [红黑树代替链表的查询复杂度及优缺点](#红黑树代替链表的查询复杂度及优缺点)
- [树状结构外的logn的数据结构](#树状结构外的logn的数据结构)
- [跳表的特性及优劣势](#跳表的特性及优劣势)
- [明星粉丝5v5分组(讲一个数组平分为两个子数组使其子数组的和尽可能接近)](#明星粉丝5v5分组讲一个数组平分为两个子数组使其子数组的和尽可能接近)
- ~为什么是用补码来实现减法~
- ~缺页的处理过程是怎样的~
- [旋转的数组中查找目标元素](#旋转的数组中查找目标元素)
- k个有序链表，合并成一个
- [一个http请求的整个过程](#一个http请求的整个过程)
- [https的处理过程](#https的处理过程)
- ORM是怎么实现的
- 联合索引的索引过程
- B+树的结构，插入一个元素的过程
- [快排和归并排序哪个是稳定的](#快排和归并排序哪个是稳定的)
- 手写链表对折，比如1,2,3,4…n对折成1,n,2,(n-1),3...: 中点断开，反转半链表, 交叉合并
- linux怎么看一个端口被什么进程占用: lsof -i:xxx
- 有序的单向链表快速查询元素: 一次移动多步;一个指针记录小于目标值得最大指针(若长度已知则可以更好的选择步长)
- 如果用数组中有很多重复元素，怎么优化快排
- ~leetcode的一个01矩阵找最大1矩阵的题目~
- 怎么实现LRU缓存，讲讲你认为的实现LRU的三个最重要的考虑点，并说说思路
- 怎么实现一个阻塞队列，说了用信号量分别同步生产者跟消费者，然后问了怎么优化

### reflect的DeepEqual方法对比逻辑
- 直接结论: 基本都是逐个成员对比; 其中func只有当都是nil 会返回true, == 也只能判断func是不是nil, 不然会panic
- [详细内容](https://golang.org/src/reflect/deepequal.go)

### golang的map实现
- 直接结论: map本身是一个8字节的指针, 指向一个hmap结构(数量(成员数及溢出bucket数), B(bucket数量为2^B), hash种子，buckets指针, oldbuckets指针, extra指向溢出bucket的指针): 特点是通过bucket的tophash(key的hash高八位快速试错), 及扩容时不全量迁移而是随着后续插入操作分批迁移
- [详细内容](/golang/basic/map.go)

### 红黑树代替链表的查询复杂度及优缺点
- 直接结论:
  - 特性: 自平衡;其查找，插入，删除的最坏时间复杂度是O(logn), 树的高度最高不会超过最低的两倍(基于特性4，5)
  - 优势: 自平衡; 相对AVL树, 牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。
  - [劣势](https://www.zhihu.com/question/27840936): 插入和删除操作相对繁琐
  - 额外扩展: Linux内核的调度系统中，进程运行队列就是使用RB-TREE实现的。
- [详细内容](https://juejin.im/post/5a27c6946fb9a04509096248): 为了解决二叉查找数最坏时间复杂度为O(n)的情况
  - 红黑树相对于二分查找树额外的条件(通过变色和左右旋转(左(右)旋: 旋转节点变为原先位置的左(右)节点)):
    - 1.节点是红色或黑色。
    - 2.根节点是黑色。
    - 3.每个叶子节点都是黑色的空节点（NIL节点）。
    - 4.每个红色节点的两个子节点都是黑色。
    - 5.任意中间节点到其叶子节点的距离有相同数量的黑节点。
    - 6.没有键值相等的节点。
  - 扩展内容: AVL树: 二分查找树的基础上, 任意节点的子树的高度的差值小于1, 通过左右旋转来自平衡
  - [何时插入(或变色)](https://www.cnblogs.com/wcd144140/p/5594746.html):
    - 二叉查找树的特性, 插入操作一般会从叶子节点开始
    - 考虑到特性5, 优先插入红色节点
      - 若父节点为红, 且父节点于其同层的兄弟节点也为红色, 包括祖节点在内优先变色
      - 若父节点为红, 且父节点于其同层的兄弟节点为黑, 考虑旋转来削减高度较高的子树

### 树状结构外的logn的数据结构
- 直接结论: (跳表)跳跃表

### 跳表的特性及优劣势
- [直接结论](https://blog.csdn.net/moakun/article/details/79928023): 特性: 通过概率实现均衡而不是强均衡以实现O(logn)的查找复杂度; 优点: 插入和删除的实现复杂度优于红黑树, 通过指针域(即指向下一个节点的指针是一个集合); 缺点: 索引占存储空间, 属于空间换时间(mysqlB+树结构的索引也是这个缺点);

### 明星粉丝5v5分组(讲一个数组平分为两个子数组使其子数组的和尽可能接近)
- 直接结论: 动态规划: 状态转移方程: S(stars, limit, fansLimit) 为在stars这个集合中, 选出limit个明星，且粉丝的综合不超过fansLimit的最大值, 10个人的话: S(stars[0:10], 5, 粉丝总数/2) = Max(选最后一个人: S(stars[0:9], 4, 粉丝总数/2 - stars[9]) + stars[9], 不选最后一人: S(stars[0:9], 5, 粉丝总数/2 ))
- [详细内容](https://www.zybuluo.com/Yano/note/253649#house-robber-ii)

### 旋转的数组中查找目标元素
旋转的意思为循环右移多少位
- [直接结论](https://leetcode.com/submissions/detail/166451714/): 数组被分成两个有序集合: 依然可以使用二分查找, 判断中位数和目标数是否在同一个有序区间来缩小范围
  - 若在同一个有效分为,则和原来一样，若大于中位数缩小前范围，反之缩小后范围
  - 若中位在大有序范围，目标在小有序范围(即中位在目标左侧)，则缩小前有序范围
  - 若中位在小有序范围，目标在大有序范围(即中位在目标右侧)，则缩小后有序范围
- 额外扩展: 关于二分查找的临界条件, 初始指针为0和末尾索引值+1(即长度), 缩小前范围前指针为中位+1, 循环条件为前指针<后指针

### 一个http请求的整个过程
- [直接结论](https://www.jianshu.com/p/a6a63e56a203): 地址输入请求(或客户端发起请求) => 域名解析=> 发起TCP的3次握手 => 建立TCP连接后发起http请求 => 服务器响应http请求(html或api数据, 若是请求api,客户端代码已拿到数据) => 浏览器解析html代码，并请求html代码中的资源(js、css、图片等) => 浏览器渲染页面
- [额外扩展](https://www.jianshu.com/p/a6a63e56a203): 域名解析顺序: 浏览器dns缓存 => 系统dns缓存 => 系统hosts文件 => 发起系统调用向系统配置的DNS服务器发起解析请求(一般指向运营商,UDP协议向DNS的53端口发起请求, 这是个递归请求, 这边通常一定会返回ip地址)

### https的处理过程
- [直接结论](https://juejin.im/post/5ab074785188255580020fa5): 客户端发起HTTPS请求(server的443端口) => 服务端返回证书(公钥，机构，地址) => 客户端校验证书(机构, 地址), 若不合法的话需要用户同意 => 生成随机数, 通过公钥加密, 发送给服务端 => 服务器通过私钥解密随机值 => 后续传输请求用该随机值加密 => 客户端用随机值解密(其中交换随机值得部分是**非对称加密**, 后续通信是通过随机值的**对称加密**)
- [额外内容](http://www.cnblogs.com/binyue/p/4500578.html):
  - 非对称加密算法：RSA，DSA/DSS
  - 对称加密算法：AES，RC4，3DES
  - HASH算法：MD5，SHA1，SHA256

### 快排和归并排序哪个是稳定的
- [前置内容](https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html): 保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同(例:Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。)
- 直接结论:
  - 冒泡排序(稳定: O(N^2); best: O(N)): 冒泡排序就是把小的元素往前调或者把大的元素往后调。若两个元素相等则不发生交换, 故稳定
  - 插入排序(稳定: O(N^2); best: O(N)): 将剩余元素依次按大小插入已有的有序集合中, 初始有序集合只有第一个元素, 若等值的元素插入在等值位置的后方, 故稳定
  - 归并排序(稳定: O(NlogN)): 用分治思想将两两分组, 分组后的元素继续分组(最小分到1个元素); 在每个分组内排序后在合并成一个大组(类似于合并两个有序链表); 在等值的情况下优先选择靠前的元素, 故稳定
  - 选择排序(不稳定: O(N^2)): 选择排序就是依次把剩余元素中最小的元素换到靠前的位置。若剩余元素的最小元素在与当前位置元素相同的元素的位置的后方, 发生交换时, 靠前的等值元素会被换到后方, 不稳定
  - 快速排序(不稳定: O(NlogN)): 快速排序左右两个指针，将小于基准值得数字放在做指针前，反之放在右指针后，放右指针后这个行为可能将等值靠后的元素换到前面, 故不稳定
  - 堆排序(不稳定: O(NlogN)): n位置的节点依次与2n+1和2n+2位置的节点比较,并将较大的值换到前方, 若n节点=2n+1节点>2n+2节点, 故不稳定

