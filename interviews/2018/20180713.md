## golang-20180713(18-16\~13)(22-16\~13)

## 索引
- [1. (golang)golang是面向什么的编程语言?](#golanggolang是面向什么的编程语言)
- [2. (golang)goroutine的具体实现](#golanggoroutine的具体实现)
- [3. (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?](#操作系统线程是内核态的协程是用户态的进程是用户态还是内核态的)
- [4. (操作系统)线程栈空间是否可以伸缩](#操作系统线程栈空间是否可以伸缩)
- [5. (操作系统)线程之间公用哪些资源](#操作系统线程之间公用哪些资源)
- [8. (设计模式)常见设计模式](#设计模式常见设计模式)

1. ### (golang)golang是面向什么的编程语言?
  - 直接结论: 一个没有对象且没有继承的面向对象的语言
  - [详细说法](https://segmentfault.com/a/1190000001832282): 面向对象将数据和代码通过“对象”集成到一起。对象是数据类型的抽象，它有状态（数据）和行为（代码）
    - 面向对象的语言应有的特性: 对象、类、继承、子类、虚方法(应在派生类中重新定义的成员方法)
    - go中的对象: 可以定义一个struct的数据类型，并为其定义方法这些数据进行交互
    - go中的继承: go中没有继承，只有组合, 对象中组合着另一个对象，访问时因为匿名域的关系不需要显示指定(但依旧是不同的对象)
    - go中的伪多态: 对象可以调用内部组合对象的方法，对象本身定义同名方法后，调用对象本身的方法(但依旧是不同的对象，接受者不同)
    - go中的多态: 接口实现多态

2. ### (golang)goroutine的具体实现
  - 直接结论: Go原生支持并发。自己实现的调度器将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度
  - [前置内容](https://juejin.im/entry/58d4ba87570c350058ca5ad8)
    - M:1(多对一)模型: 多个协程对应一个线程(优点: 避免了上下文切换造成的开销. 缺点: 只用到1个CPU，io时阻塞时集体阻塞，实现复杂度)
    - 1:1(一对一)模型: 一个协程对应一个线程, 调度由线程调度(优点: 用上了多核. 缺点: 内核调度，开销大)
    - M:N(多对多)模型: 多个协程对应多个线程, 调度由用户调度.
    - 关于 M, P, G模型: 
    - M即Machine，由os创建出来的实体线程(通常各自对应一个cpu)，由操作系统管理，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
    - P即Processor，处理器，用于执行goroutine，它维护了一个goroutine队列(runqueue)。
    - G即goroutine的核心，它包含了栈，指令指针及其他重要信息
  - [详细内容](https://github.com/k2huang/blogpost/blob/master/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6/Go%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6.md): go的并发具体流程:
    - 假如我们有一个G(GoroutineMain)已经通过P被安排到了一个M上正在执行。
    - 在GoroutineMain执行的过程中我们又创建两个G，这两个G会被马上放入与GoroutineMain相同的P的runqueue中，排队等待与该P绑定的M的执行.
    - **情况1**: 若我们在一个Goroutine中创建了大量G，这些G暂时会被放在同一个runqueue中, 此时若有空闲P的同时也有活跃的M，该M会与该P绑定去各种G队列去寻找可运行的G任务(即自旋M)
      - 一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。由于全局队列需要锁保护，若里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。若全局队列还是没有，会从其他P队列偷一半任务。故这样在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上.
    - **情况2**: 若某个M在执行G的过程中被G中的系统调用阻塞了: 此时该M将会被内核调度器调度出CPU, 同时并处于阻塞状态,这时与该M关联的P中的其他G就没有办法继续执行了。
      - 但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G。
      - 然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。
    - **情况3**: 若某个G在M运行时间过长，是否存在抢占式调度，让该M上的其他G运行，以保证调度系统的公平性?
      - Go的runtime调度器中有类似线程的抢占机制，不保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过(监控线程)向运行时间过长的G中设置抢占flag让该G自己主动让出M的执行权。Go抢占式调度的机制就是利用在调用判断要不要扩栈的时候顺便查看以下自己的抢占flag，是否让出自己。若让出的话自己会被放到全局队列该队列上其他g即可执行(ps:如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务)
      - *补充内容1*: 我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程"饿死"的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。
      - *补充内容2*: 说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。

3. ### (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?
  - 直接结论: 进程即是用户态，又是内核态的, 进程有用户态和内核态两个状态
  - [详细说法](https://segmentfault.com/q/1010000002688489): Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，内核栈就是用于内核态的堆栈。运行在**用户态的程序不能访问操作系统内核数据结构和程序**。 内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。简单的说，用户程序只能访问内存，而操作系统能访问所有数据。用户程序工作的模式即是用户态，当用户程序想要访问受限的数据时，就需要向操作系统发请求(系统调用)，让操作系统帮忙完成。 操作系统工作在内核态。
    - 什么是内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
    - 什么是用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
    - 什么是系统调用: 所有的操作系统都会提供一些服务用以访问/操作设备等，操作系统会为这些服务提供接口。这些接口就是系统调用 。用户态程序通过调用系统调用可以切换到内核态，访问内存意外的数据，操作外围设备等。
  - [其他扩展](https://blog.csdn.net/hnulwt/article/details/41210941):
    - 进程: 是有**独立功能**的**程序**关于某个**数据集合**上的一次**运行活动**,是系统进行*资源*分配和调度的一个独立单位。
    - 线程: 是进程的一个实体,是*CPU*调度和分派的基本单位,线程自己基本上不拥有系统资源(除去必需的资源如: 程序计数器,一组寄存器和栈),与同一进程的其他的线程共享进程所有资源.  一个线程可以创建和撤销另一个线程;

4. ### (操作系统)线程栈空间是否可以伸缩
  - 直接结论: 线程栈是固定大小的，可以使用ulimit -a 查看，使用ulimit -s 修改, 故不能伸缩
  - [其他扩展](https://blog.csdn.net/Evankaka/article/details/44457765):
    - 栈为何相对于堆要小: 堆进程内共用，栈是线程独占，一个进程包含多个线程，所以堆就有必要比栈大了。通常编程不会把大量数据放到栈里, 所以栈一般也不会弄的太大。
    - 关于堆: 是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
    - 关于栈: 是个线程独有的，保存线程运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，故thread safe的。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈。栈空间不需要在高级语言里面显式的分配和释放。额外提一下: [进程栈的大小是在执行时刻才能指定的](https://www.cnblogs.com/luosongchao/p/3680312.html)

5. ### (操作系统)线程之间公用哪些资源
  - 直接结论: 全局堆, 进程的公有数据(全局变量), 文件，进程打开的文件描述符, 信号的处理器、进程的当前目录和进程用户ID与进程组ID
  - [其他扩展](https://blog.csdn.net/sunning9001/article/details/46851797):
    - 关于线程独有的部分: 每个线程都有它自己的线程上下文.线程上下文包括：线程ID,栈,栈指针,程序计数器,条件码和通用寄存器的值。

8. ### (设计模式)常见设计模式(s/类/struct)
  - 直接结论: 单例, 策略，工厂，代理，装饰器, 状态，template
    - **单例模式**(创建型): 一个类只有一个实例对象:
      - 详细描述: 一个类只有一个实例对象(比如说日志类，只要一个实例即可):
      - 用途&优劣: 用于控制内存开销; 优: 节省内存开销; 劣: 一个类不该关心外部实例化方式
      - 相关实现: 私有的构造方法,获取实例的静态方法(懒汉模式下，判断是否有现成实例注意线程安全, golang中可以用once:=sync.Once{}, once.Do(oneFunc)), 生成的实例保存在类私有成员中.
    - **策略模式**(行为类, 即对在不同的对象之间划分责任和算法的抽象化): 基本等同与golang中interface做的事:
      - 详细描述: 把不同的算法封装成不同的类，根据具体情况调用，而不是通过if/else判断, 就像同一接口使用不同策略一样(golang中的接口):
      - 用途&优劣: 用于一个系统存在仅算法行为不同的类，避免条件判断; 优: 避免复杂条件判断; 劣: 策略类会增多
      - 相关实现: golang中即用interface声明方法, 在定义一个策略struct内含有该interface成员, 或者在某一个方法中已参数传入不同的对象实例(golang中直接给接口赋值即可，感觉额外定义一个struct有些多余, 不过会更类似策略这个名称)
    - **工厂模式**(创建型): 有一个(工厂类)构造方法, 根据条件返回不同的实例(以interface形式)
      - 详细描述: 在创建对象时隐藏创建的逻辑细节，并已被实现的接口形式返回创建的对象(golang中即在自定义的构造方法中返回一个接口)。就像工厂一般实现告知产品类型/条件，返回对应实例(产品)
      - 用途&优劣: 用于不同的情况创建不同的实例，实例化过程在各自的子类中完成(golang没有继承/子类)，如orm传入不同的数据库类型参数，生成对应的实例, 隐藏实例化细节; 优: 屏蔽了具体实现, 可扩展; 劣: 工厂类的复杂度会随着产品数量增多
      - 相关实现: golang中即用interface声明同类产品的方法, 自定义各个类的构造方法，再专门自定义一个根据条件返回不同类型实例的工厂(类)方法.
    - **代理模式**(结构型,即将类或者对象结合在一起形成更大的结构): 可以理解在一个类外层包了一个类，外层的类中对包裹的数个方法组合后封装成一个新方法
      - 详细描述: 一个类代表另一个类的功能。我们创建具有现有对象的对象，以便向外界提供功能接口。就像一个代理商代理了复数服务一般
      - 用途&优劣: 用于为使用一个类进行一些控制(例子(不一定很合适): 比如某一个类在调用某一方法时必须实现数个前置方法), 为其提供一代理类(并作为成员组合了该类), 并实现了同名方法，并执行了前置方法; 优: 职责拆分明确; 劣: 多了一个类的开销
      - 相关实现: golang中即用interface声明同类产品的方法, 自定义各个类的构造方法，再专门自定义一个根据条件返回不同类型实例的工厂(类)方法.
    - **装饰器模式**(结构型): 可以理解在一个类外层包了一个类，外层的类中对包裹的数个方法进行再封装(例如调用前执行些额外的内容)
      - 详细描述: 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类进行一些额外的装饰。
      - 用途&优劣: 在不想增加很多子类的情况下扩展类.; 优: 解耦，动态扩展动态撤销; 劣: 多层装饰复杂度
      - 相关实现: 和代理模式差不多。其实仅有一个装饰方法也行, 例如gin的handleFunc外包一个装饰函数来recover panic;
    - **状态模式**(行为类): 基本和策略模式差不多, 区别是状态模式由对象自身来管理它的状态, 策略模式由调用方可以选择不同的行为。
      - 详细描述: 当一个对象的内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类:
      - 用途&优劣: 对象的行为依赖于它的状态(属性)，并且可以根据它的状态改变而改变它的相关行为; 优: 减少了对依赖状态的条件语句, 封装了状态切换的细节; 劣: 策略类会增多
      - 相关实现: golang中即用interface声明方法, 在定义一个struct内含有该interface成员.有个方法可以切换这个接口成员.
    - **模板模式**(行为类): 即父类暴露了一个方法并封装了一些操作, 这些操作由子类实现, 调用从抽象类调用
      - 详细描述: 一个抽象类公开定义了封装了子类具体实现的方法(需要同名)(模板)。它的子类可以按需要重写方法实现，由抽象类调用。
      - 用途&优劣: 用于减少一些通用的方法却要在子类中重新实现一遍; 优: 减少了重复代码; 劣: 子类的数量会增多
      - 相关实现: golang中没有继承, 若用接口类型成员来实现的话更像是代理模式

开发高并发产品的难点(协议栈，对象的复用，各种复用，文件描述符)
单台物流服务器最大连接数，多个实例呢

分布式集群
mongodb,redis集群落实
分表分库(取模(迁移)，分类型(时间(热点问题)，地区(细分)))
context具体实现
分布式中间件落实(数据库中间件)
docker优势, 劣势
图，深度优先，广度优先
服务治理用途

刚开始学习时使用的golang版本和当前使用的最新版本

