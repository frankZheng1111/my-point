## golang-20180713-1(18-16)
1. ### (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?
  - 直接结论: 进程即是用户态，又是内核态的, 进程有用户态和内核态两个状态
  - [详细说法](https://segmentfault.com/q/1010000002688489): Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，内核栈就是用于内核态的堆栈。运行在**用户态的程序不能访问操作系统内核数据结构和程序**。 内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。简单的说，用户程序只能访问内存，而操作系统能访问所有数据。用户程序工作的模式即是用户态，当用户程序想要访问受限的数据时，就需要向操作系统发请求(系统调用)，让操作系统帮忙完成。 操作系统工作在内核态。
    - 什么是内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
    - 什么是用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
    - 什么是系统调用: 所有的操作系统都会提供一些服务用以访问/操作设备等，操作系统会为这些服务提供接口。这些接口就是系统调用 。用户态程序通过调用系统调用可以切换到内核态，访问内存意外的数据，操作外围设备等。
  - [其他扩展](https://blog.csdn.net/hnulwt/article/details/41210941):
    - 进程: 是有**独立功能**的**程序**关于某个**数据集合**上的一次**运行活动**,是系统进行*资源*分配和调度的一个独立单位。
    - 线程: 是进程的一个实体,是*CPU*调度和分派的基本单位,线程自己基本上不拥有系统资源(除去必需的资源如: 程序计数器,一组寄存器和栈),与同一进程的其他的线程共享进程所有资源.  一个线程可以创建和撤销另一个线程;

开发高并发产品的难点(协议栈，对象的复用，各种复用，文件描述符)
线程栈空间是否可以伸缩
单台物流服务器最大连接数，多个实例呢
线程间公用的资源(地址，栈，空间等)
goroutine 具体实现
设计模式
golang 面向？编程

分布式集群
mongodb,redis集群落实
分表分库(取模(迁移)，分类型(时间(热点问题)，地区(细分)))
context具体实现
分布式中间件落实(数据库中间件)
docker优势, 劣势

