# golang-20180713(18-16\~13)(22-16\~13)

## 索引
- [(golang)golang是面向什么的编程语言?](#golanggolang是面向什么的编程语言)
- [(golang)goroutine的具体实现](#golanggoroutine的具体实现)
- [(golang)chan的用途](#golangchan的用途)
- [(操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?](#操作系统线程是内核态的协程是用户态的进程是用户态还是内核态的)
- [(操作系统)线程栈空间是否可以伸缩](#操作系统线程栈空间是否可以伸缩)
- [(操作系统)线程之间公用哪些资源](#操作系统线程之间公用哪些资源)
- [(设计模式)常见设计模式](#设计模式常见设计模式s类struct)
- [(工程相关)docker的优点和缺点](#工程相关docker的优点和缺点)
- [(工程相关)数据库水平切分的用途和优劣势](#工程相关数据库水平切分的用途和优劣势)
- [(工程相关)数据库水平切分策略及各自优劣](#工程相关数据库水平切分策略及各自优劣)
- [(工程相关)服务治理的用途](#工程相关服务治理的用途)
- [(工程相关)开发高并发服务的难点](#工程相关开发高并发服务的难点)
- [(工程相关)关于Linux服务器最大tcp连接数](#工程相关关于Linux服务器最大tcp连接数)
- [(工程相关)关于Linux服务器最大tcp连接数](#工程相关关于Linux服务器最大tcp连接数)
- [(具体落实)数据库中间件](#具体落实数据库中间件)

## golang相关

### (golang)golang是面向什么的编程语言?
  - 直接结论: 一个没有对象且没有继承的面向对象的语言
  - [详细说法](https://segmentfault.com/a/1190000001832282): 面向对象将数据和代码通过“对象”集成到一起。对象是数据类型的抽象，它有状态（数据）和行为（代码）
    - 面向对象的语言应有的特性: 对象、类、继承、子类、虚方法(应在派生类中重新定义的成员方法)
    - go中的对象: 可以定义一个struct的数据类型，并为其定义方法这些数据进行交互
    - go中的继承: go中没有继承，只有组合, 对象中组合着另一个对象，访问时因为匿名域的关系不需要显示指定(但依旧是不同的对象)
    - go中的伪多态: 对象可以调用内部组合对象的方法，对象本身定义同名方法后，调用对象本身的方法(但依旧是不同的对象，接受者不同)
    - go中的多态: 接口实现多态

### (golang)chan的用途
  - 直接结论: 用于goroutine之间通信: 可以用于生产者消费者模型, 也可以用于停止某个goroutine(该goroutine用select轮询, 详见context的底层实现)

### (golang)goroutine的具体实现
  - 直接结论: Go原生支持并发。自己实现的调度器将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度
  - [前置内容](https://juejin.im/entry/58d4ba87570c350058ca5ad8)
    - M:1(多对一)模型: 多个协程对应一个线程(优点: 避免了上下文切换造成的开销. 缺点: 只用到1个CPU，io时阻塞时集体阻塞，实现复杂度)
    - 1:1(一对一)模型: 一个协程对应一个线程, 调度由线程调度(优点: 用上了多核. 缺点: 内核调度，开销大)
    - M:N(多对多)模型: 多个协程对应多个线程, 调度由用户调度.
    - 关于 M, P, G模型:
    - M即Machine，由os创建出来的实体线程(通常各自对应一个cpu)，由操作系统管理，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
    - P即Processor，处理器，用于执行goroutine，它维护了一个goroutine队列(runqueue)。
    - G即goroutine的核心，它包含了栈，指令指针及其他重要信息
  - [详细内容](https://github.com/k2huang/blogpost/blob/master/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6/Go%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6.md): go的并发具体流程:
    - 假如我们有一个G(GoroutineMain)已经通过P被安排到了一个M上正在执行。
    - 在GoroutineMain执行的过程中我们又创建两个G，这两个G会被马上放入与GoroutineMain相同的P的runqueue中，排队等待与该P绑定的M的执行.
    - **情况1**: 若我们在一个Goroutine中创建了大量G，这些G暂时会被放在同一个runqueue中, 此时若有空闲P的同时也有活跃的M，该M会与该P绑定去各种G队列去寻找可运行的G任务(即自旋M)
      - 一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。由于全局队列需要锁保护，若里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。若全局队列还是没有，会从其他P队列偷一半任务。故这样在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上.
    - **情况2**: 若某个M在执行G的过程中被G中的系统调用阻塞了: 此时该M将会被内核调度器调度出CPU, 同时并处于阻塞状态,这时与该M关联的P中的其他G就没有办法继续执行了。
      - 但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G。
      - 然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。
    - **情况3**: 若某个G在M运行时间过长，是否存在抢占式调度，让该M上的其他G运行，以保证调度系统的公平性?
      - Go的runtime调度器中有类似线程的抢占机制，不保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过(监控线程)向运行时间过长的G中设置抢占flag让该G自己主动让出M的执行权。Go抢占式调度的机制就是利用在调用判断要不要扩栈的时候顺便查看以下自己的抢占flag，是否让出自己。若让出的话自己会被放到全局队列该队列上其他g即可执行(ps:如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务)
      - *补充内容1*: 我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程"饿死"的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。
      - *补充内容2*: 说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。

## 操作系统相关

### (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?
  - 直接结论: 进程即是用户态，又是内核态的, 进程有用户态和内核态两个状态
  - [详细说法](https://segmentfault.com/q/1010000002688489): Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，内核栈就是用于内核态的堆栈。运行在**用户态的程序不能访问操作系统内核数据结构和程序**。 内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。简单的说，用户程序只能访问内存，而操作系统能访问所有数据。用户程序工作的模式即是用户态，当用户程序想要访问受限的数据时，就需要向操作系统发请求(系统调用)，让操作系统帮忙完成。 操作系统工作在内核态。
    - 什么是内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
    - 什么是用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
    - 什么是系统调用: 所有的操作系统都会提供一些服务用以访问/操作设备等，操作系统会为这些服务提供接口。这些接口就是系统调用 。用户态程序通过调用系统调用可以切换到内核态，访问内存意外的数据，操作外围设备等。
  - [其他扩展](https://blog.csdn.net/hnulwt/article/details/41210941):
    - 进程: 是有**独立功能**的**程序**关于某个**数据集合**上的一次**运行活动**,是系统进行*资源*分配和调度的一个独立单位。
    - 线程: 是进程的一个实体,是*CPU*调度和分派的基本单位,线程自己基本上不拥有系统资源(除去必需的资源如: 程序计数器,一组寄存器和栈),与同一进程的其他的线程共享进程所有资源.  一个线程可以创建和撤销另一个线程;

### (操作系统)线程栈空间是否可以伸缩
  - 直接结论: 线程栈是固定大小的，可以使用ulimit -a 查看，使用ulimit -s 修改, 故不能伸缩
  - [其他扩展](https://blog.csdn.net/Evankaka/article/details/44457765):
    - 栈为何相对于堆要小: 堆进程内共用，栈是线程独占，一个进程包含多个线程，所以堆就有必要比栈大了。通常编程不会把大量数据放到栈里, 所以栈一般也不会弄的太大。
    - 关于堆: 是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
    - 关于栈: 是个线程独有的，保存线程运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，故thread safe的。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈。栈空间不需要在高级语言里面显式的分配和释放。额外提一下: [进程栈的大小是在执行时刻才能指定的](https://www.cnblogs.com/luosongchao/p/3680312.html)

### (操作系统)线程之间公用哪些资源
  - 直接结论: 全局堆, 进程的公有数据(全局变量), 文件，进程打开的文件描述符, 信号的处理器、进程的当前目录和进程用户ID与进程组ID
  - [其他扩展](https://blog.csdn.net/sunning9001/article/details/46851797):
    - 关于线程独有的部分: 每个线程都有它自己的线程上下文.线程上下文包括：线程ID,栈,栈指针,程序计数器,条件码和通用寄存器的值。

## 设计模式相关

### (设计模式)常见设计模式(s/类/struct)
  - 直接结论: 单例, 策略，工厂，代理，装饰器, 状态，template
    - **单例模式**(创建型): 一个类只有一个实例对象:
      - 详细描述: 一个类只有一个实例对象(比如说日志类，只要一个实例即可):
      - 用途&优劣: 用于控制内存开销; 优: 节省内存开销; 劣: 一个类不该关心外部实例化方式
      - 相关实现: 私有的构造方法,获取实例的静态方法(懒汉模式下，判断是否有现成实例注意线程安全, golang中可以用once:=sync.Once{}, once.Do(oneFunc)), 生成的实例保存在类私有成员中.
    - **策略模式**(行为类, 即对在不同的对象之间划分责任和算法的抽象化): 基本等同与golang中interface做的事:
      - 详细描述: 把不同的算法封装成不同的类，根据具体情况调用，而不是通过if/else判断, 就像同一接口使用不同策略一样(golang中的接口):
      - 用途&优劣: 用于一个系统存在仅算法行为不同的类，避免条件判断; 优: 避免复杂条件判断; 劣: 策略类会增多
      - 相关实现: golang中即用interface声明方法, 在定义一个策略struct内含有该interface成员, 或者在某一个方法中已参数传入不同的对象实例(golang中直接给接口赋值即可，感觉额外定义一个struct有些多余, 不过会更类似策略这个名称)
    - **工厂模式**(创建型): 有一个(工厂类)构造方法, 根据条件返回不同的实例(以interface形式)
      - 详细描述: 在创建对象时隐藏创建的逻辑细节，并已被实现的接口形式返回创建的对象(golang中即在自定义的构造方法中返回一个接口)。就像工厂一般实现告知产品类型/条件，返回对应实例(产品)
      - 用途&优劣: 用于不同的情况创建不同的实例，实例化过程在各自的子类中完成(golang没有继承/子类)，如orm传入不同的数据库类型参数，生成对应的实例, 隐藏实例化细节; 优: 屏蔽了具体实现, 可扩展; 劣: 工厂类的复杂度会随着产品数量增多
      - 相关实现: golang中即用interface声明同类产品的方法, 自定义各个类的构造方法，再专门自定义一个根据条件返回不同类型实例的工厂(类)方法.
    - **代理模式**(结构型,即将类或者对象结合在一起形成更大的结构): 可以理解在一个类外层包了一个类，外层的类中对包裹的数个方法组合后封装成一个新方法
      - 详细描述: 一个类代表另一个类的功能。我们创建具有现有对象的对象，以便向外界提供功能接口。就像一个代理商代理了复数服务一般
      - 用途&优劣: 用于为使用一个类进行一些控制(例子(不一定很合适): 比如某一个类在调用某一方法时必须实现数个前置方法), 为其提供一代理类(并作为成员组合了该类), 并实现了同名方法，并执行了前置方法; 优: 职责拆分明确; 劣: 多了一个类的开销
      - 相关实现: golang中即用interface声明同类产品的方法, 自定义各个类的构造方法，再专门自定义一个根据条件返回不同类型实例的工厂(类)方法.
    - **装饰器模式**(结构型): 可以理解在一个类外层包了一个类，外层的类中对包裹的数个方法进行再封装(例如调用前执行些额外的内容)
      - 详细描述: 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类进行一些额外的装饰。
      - 用途&优劣: 在不想增加很多子类的情况下扩展类.; 优: 解耦，动态扩展动态撤销; 劣: 多层装饰复杂度
      - 相关实现: 和代理模式差不多。其实仅有一个装饰方法也行, 例如gin的handleFunc外包一个装饰函数来recover panic;
    - **状态模式**(行为类): 基本和策略模式差不多, 区别是状态模式由对象自身来管理它的状态, 策略模式由调用方可以选择不同的行为。
      - 详细描述: 当一个对象的内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类:
      - 用途&优劣: 对象的行为依赖于它的状态(属性)，并且可以根据它的状态改变而改变它的相关行为; 优: 减少了对依赖状态的条件语句, 封装了状态切换的细节; 劣: 策略类会增多
      - 相关实现: golang中即用interface声明方法, 在定义一个struct内含有该interface成员.有个方法可以切换这个接口成员.
    - **模板模式**(行为类): 即父类暴露了一个方法并封装了一些操作, 这些操作由子类实现, 调用从抽象类调用
      - 详细描述: 一个抽象类公开定义了封装了子类具体实现的方法(需要同名)(模板)。它的子类可以按需要重写方法实现，由抽象类调用。
      - 用途&优劣: 用于减少一些通用的方法却要在子类中重新实现一遍; 优: 减少了重复代码; 劣: 子类的数量会增多
      - 相关实现: golang中没有继承, 若用接口类型成员来实现的话更像是代理模式

## 工程相关

### (工程相关)docker的优点和缺点
  - 直接结论: 
    - 优点: 相当于一个轻量级vm, 可以在一个统一的环境下运行一段程序或者起一个服务，避免了反复搭建环境
    - 缺点:
      - 产品实际使用的复杂性(需要很多技术的支撑，比如说，容器管理、编排、应用打包、容器间的网络、数据快照, 可视化等等)
      - 实用性局限于应用程序或独立服务，但并不包含数据。日志，跟踪和数据库等通常应映射到Docker容器外。

### (工程相关)数据库水平切分的用途和优劣势
  - 直接结论: 优点: 解决数据库物理瓶颈(包括但不限于连接数，单表数据性能上限); 缺点: 增加数据库使用和维护的成本和复杂度;
  - [详细内容](https://www.scienjus.com/database-sharding-review/): 数据库优化方案: 1. 一个数据库; 2. 数据库主从分离，从数据库作为容灾备份; 3.数据库读写分类; 分摊压力至2个数据库; 4. 垂直分库(按业务或拆表(少于255列))，进一步分摊压力; 5. 水平分库(单表小于500万?), 分摊压力至多台数据库服务器;
  - 若使用hash分表, 会有已下问题:
    - 遍历查询需要多次查询, 分页也有性能问题(解决办法是在额外建立一张索引表，保存 id 和排序、筛选字段，先从索引表中查询对应的 id，再通过 id 去查询具体信息。索引表如果不是很复杂的话，完全可以通过 Redis 的 zset 和 list 实现。)
    - 主键冲突(snowflake算法)
    - 无法联合查询
    - 查询条件若不在同一个库中，要么冗余查询条件，要么在一个库中先查出所有结果
    - 尽量将不同表中相关联的数据放在同一分片下(如同一个用户和他发的所有微博), 最坏情况下考虑冗余(2条关联的数据在不同的库, 各个分片各自保留数据)

### (工程相关)数据库水平切分策略及各自优劣
  - 直接结论: 号段分区，时间段分区，hash取模， 在另一个库中保存数据库与其他值得映射信息(不管哪种方案查询都需要和分区相关联的字段, 否则可能要遍历所有分区才能找到结果).
    - 号段分区: 根据特定字段进行分区(适合有浓厚的分割标志的字段), 举例说日常用户写入数据，根据用户Id, id为1～1000的对应DB1，1001～2000的对应DB2，以此类推;
      - 优点: 扩展表, 数据迁移成本非常小
      - 缺点: 数据分配不匀, 需要预估单库承担的数据量，不然会浪费或不够
    - 时间段分区: 比如说将过去一年的数据放在一张表内，以此类推;
      - 优点: 扩展表, 数据迁移成本非常小
      - 缺点: 数据分配不匀, 同时存在热点问题(一般来说越新的数据越容易被使用,适用于weibo时间轴之类的场景, 虽然容易查到数据，但是相对压力大)
    - 地区分区: 比如说将特定区域的数据放在一张表内，以此类推;
      - 优点: 扩展表, 数据迁移成本非常小
      - 缺点: 数据分配不匀, 几个大城市需要额外分区(可以把数据库服务器设在就近的节点)
    - hash取模分区: 假设已有4张表，根据查询字段的hash值进行取模, 根据模值放进对应的表里
      - 优点: 数据分布均匀
      - 缺点: 存在迁移成本(用一致性hash一定程度上降低迁移成本)
    - 额外保存映射关系: 额外的DB单独保存查询字段到DB的映射关系，查询前先查询这个DB
      - 优点：灵活性强，一对一映射
      - 缺点：多一次查询(一般会缓存)

### (工程相关)服务治理的用途
  - 直接结论: 服务发现和注册, 服务监控, 集群容错, 其他支持(扩容，熔断,降级)
  - [详细扩展](https://blog.csdn.net/suifeng3051/article/details/53992560):
    - 架构演化: 一体化架构 => mvc架构 => 多应用架构(认证, 订单, 评价系统) => 分布式架构(垂直(微服务)，水平拆分(集群)): 需要服务治理, 服务治理可以:
    - 服务服务发现注册:
      - 服务提供者启动，向注册中心注册自己提供的服务
      - 消费者启动，向注册中心订阅自己需要的服务
      - 注册中心返回服务提供者的列表给消费者(即注册中心宕机不会影响消费者)
      - 消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求
    - 服务监控;
    - 集群容错;
    - 部分框架支持(扩容(增加实例)，熔断(下层服务挂掉)，降级(主动减少下层负载))

### (工程相关)开发高并发服务的难点
  开发高并发产品的难点(协议栈，对象的复用，各种复用，文件描述符 c10k)
  - 直接结论: 数据结构设计水平要求, 缓存, 架构支持(读写分离，水平切分), 内存管理(包括但不仅限对象的复用), 连接的复用
  - 直接结论: 读写分离/分库分表(提高数据库层面的并发性能), 缓存(redis, memcache各种集群), hash(空间换时间)
  - [关于什么是高并发](https://blog.csdn.net/hel12he/article/details/77561718): 按照一天: 200w的pv, 80%的请求集中在20%的时间: 200w * 0.8 / (24 * 3600 * 0.2) = 92.6qps, 即1s得处理92.6个请求
  - [开发高并发服务优化顺序](https://juejin.im/entry/575e1fc4d342d30057a07557)
    - 适用于秒杀场景(仅需尽快返回数据): 读写分离/分库分表(提高数据库层面的并发性能), 缓存(redis, memcache各种集群), hash(空间换时间), 合适的数据结构，性能优化:
      - 扩展12306购票场景: 由于购票服务有票数限制，故不可能满足所有人，故通过秒杀场景的方案优化体验，通过验证码手段异步错峰提供服务即可
    - 设计合理的数据结构(包括设计的数据结构,例如lru算法的结构设计(链表维护最新命中的数据键值，hash维护键值对)
    - 优化代码性能(尽可能逼近理论值)
    - 上外部通用方案(比如说热词搜索可以上个lru缓存)
    - 通过运维架构提高并发能力
  https://github.com/xiaojiaqi/10billionhongbaos
  - [go性能优化](http://lanlingzi.cn/post/technical/2017/0203\_go\_optimize/):
    - 小对象合并成结构体一次分配，减少内存分配次数
    - byte.Buffer(Grow方法), slice, map，预先分配足够的内存, 减少扩容次数
    - 控制调用栈和函数的复杂度，不要在一个goroutine做完所有逻辑；
    - 如的确需要长调用栈，而考虑goroutine池化，避免频繁创建goroutine带来栈空间的变化。
    - goroutine池化, 控制goroutine数量避免挤压
    - 减少[]byte和string的转换
    - 运用对象池实现对象的复用，减少gc的压力

  https://blog.qiniu.com/archives/3720
  https://zhuanlan.zhihu.com/p/26695984
  https://my.oschina.net/xianggao/blog/664275

### (工程相关)关于Linux服务器最大tcp连接数
  - 直接结论: 理论最大tcp连接数约为(ipv4)2的32次方（ip数）×2的16次方（port数）, 实际应用增加内存和增加进程可用的最大文件描述符(), 可达10w，也有单机50w连接
  - [详细内容](https://www.cnblogs.com/fjping0606/p/4729389.html): 系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。
    - client理论最大tcp连接数: client每次发起tcp连接请求时，若不绑定端口，默认让系统选取一个空闲的本地端口（local port），该端口独占，不与其他连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536(2的16次方)，端口0不能用(socket bind时作为参数，表示由内核分配端口)，故**最大tcp连接数为65535**(全部作为客户端)，这些连接可以连到不同的server ip。
    - server理论最大tcp连接数: server一般监听一个本地端口，等待client的连接请求。不考虑地址重用（unix的SO\_REUSEADDR选项），即使server端有多个ip，本地监听端口也是独占的(只能被一个服务监听)，故确认连接的条件只有客户端ip和port是可变，对IPV4，不考虑ip地址分类等因素，故最大tcp连接数约为2的32次方(ip数）×2的16次方(port数)，即**server端单机最大tcp连接数约为2的48次方**。
    - server实际最大tcp连接数: 受到机器资源、操作系统等的限制，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是**内存和允许的文件描述符个数**（每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。默认2.6内核配置下，每个socket占用15~20k, 增加内存、修改最大文件描述符个数等参数，**单机最大并发TCP连接数超过10万**, 是没问题的(国外 Urban Airship 公司在产品环境中已做到 50 万并发), 在实际应用中，对大规模网络应用，还需要考虑C10K(同时保持1w个连接)问题。

## 具体落实相关

### (具体落实)数据库中间件
  - 直接结论:
    - [kingshard](https://github.com/flike/kingshard): 可以配置主从分离, 负载均衡，跨节点水平分库及部分聚合函数(hash, 号段分区), 单节点事务
  - [其他分库分表中间件工具(未使用过)](https://www.jianshu.com/p/b1395b680818):
    - [Atlas(360)](https://github.com/Qihoo360/Atlas)
    - [heisenberg(baidu)](https://github.com/songwie/heisenberg)
    - [cobar(alibaba)](https://github.com/alibaba/cobar): 貌似不支持主从分离
    - [myCat(基于Cobar)](http://www.mycat.org.cn/)


分布式集群
mongodb,redis集群落实

图，深度优先，广度优先

