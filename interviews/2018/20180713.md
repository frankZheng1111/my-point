## golang-20180713-1(18-16\~13)(22-16\~13)

## 索引
- [1. (golang)golang是面向什么的编程语言?](#golanggolang是面向什么的编程语言)
- [2. (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?](#操作系统线程是内核态的协程是用户态的进程是用户态还是内核态的)
- [3. (操作系统)线程栈空间是否可以伸缩](#操作系统线程栈空间是否可以伸缩)

1. ### (golang)golang是面向什么的编程语言?
  - 直接结论: 一个没有对象且没有继承的面向对象的语言
  - [详细说法](https://segmentfault.com/a/1190000001832282): 面向对象将数据和代码通过“对象”集成到一起。对象是数据类型的抽象，它有状态（数据）和行为（代码）
    - 面向对象的语言应有的特性: 对象、类、继承、子类、虚方法(应在派生类中重新定义的成员方法)
    - go中的对象: 可以定义一个struct的数据类型，并为其定义方法这些数据进行交互
    - go中的继承: go中没有继承，只有组合, 对象中组合着另一个对象，访问时因为匿名域的关系不需要显示指定(但依旧是不同的对象)
    - go中的伪多态: 对象可以调用内部组合对象的方法，对象本身定义同名方法后，调用对象本身的方法(但依旧是不同的对象，接受者不同)
    - go中的多态: 接口实现多态

2. ### (操作系统)线程是内核态的，协程是用户态的，进程是用户态还是内核态的?
  - 直接结论: 进程即是用户态，又是内核态的, 进程有用户态和内核态两个状态
  - [详细说法](https://segmentfault.com/q/1010000002688489): Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，内核栈就是用于内核态的堆栈。运行在**用户态的程序不能访问操作系统内核数据结构和程序**。 内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。简单的说，用户程序只能访问内存，而操作系统能访问所有数据。用户程序工作的模式即是用户态，当用户程序想要访问受限的数据时，就需要向操作系统发请求(系统调用)，让操作系统帮忙完成。 操作系统工作在内核态。
    - 什么是内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
    - 什么是用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取
    - 什么是系统调用: 所有的操作系统都会提供一些服务用以访问/操作设备等，操作系统会为这些服务提供接口。这些接口就是系统调用 。用户态程序通过调用系统调用可以切换到内核态，访问内存意外的数据，操作外围设备等。
  - [其他扩展](https://blog.csdn.net/hnulwt/article/details/41210941):
    - 进程: 是有**独立功能**的**程序**关于某个**数据集合**上的一次**运行活动**,是系统进行*资源*分配和调度的一个独立单位。
    - 线程: 是进程的一个实体,是*CPU*调度和分派的基本单位,线程自己基本上不拥有系统资源(除去必需的资源如: 程序计数器,一组寄存器和栈),与同一进程的其他的线程共享进程所有资源.  一个线程可以创建和撤销另一个线程;

3. ### (操作系统)线程栈空间是否可以伸缩
  - 直接结论: 线程栈是固定大小的，可以使用ulimit -a 查看，使用ulimit -s 修改, 故不能伸缩
  - [其他扩展](https://blog.csdn.net/Evankaka/article/details/44457765):
    - 栈为何相对于堆要小: 堆进程内共用，栈是线程独占，一个进程包含多个线程，所以堆就有必要比栈大了。通常编程不会把大量数据放到栈里, 所以栈一般也不会弄的太大。
    - 关于堆: 是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
    - 关于栈: 是个线程独有的，保存线程运行状态和局部变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，故thread safe的。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈。栈空间不需要在高级语言里面显式的分配和释放。


开发高并发产品的难点(协议栈，对象的复用，各种复用，文件描述符)
单台物流服务器最大连接数，多个实例呢
线程间公用的资源(地址，栈，空间等)
goroutine 具体实现
设计模式

分布式集群
mongodb,redis集群落实
分表分库(取模(迁移)，分类型(时间(热点问题)，地区(细分)))
context具体实现
分布式中间件落实(数据库中间件)
docker优势, 劣势

