# golang-20180720

## 索引
- [(redis)redis为何被设计成单线程?](#redisredis为何被设计成单线程)
- [(golang)为什么gin的路由性能好](#golang为什么gin的路由性能好)
- [(微服务)golang有哪些rpc框架](#微服务golang有哪些rpc框架)
- [(微服务)微服务拆分要坚持哪些原则, 要做到什么度](#微服务微服务拆分要坚持哪些原则, 要做到什么度)

## 关于golang

### (golang)为什么gin的路由性能好
- 直接结论: 路由块用了httprouter, json序列化用了jsoniter(高性能著称, 貌似from滴滴的工程师). httprouter性能好因为他是自己写的优化，没有用标准库
- [详细内容](http://www.csyangchen.com/go-http-router.html): 为什么httprouter性能好:
  - http.ServeMux: 标准库自带的URL路由, 每个路径注册到一个map(类型是map[string(即pattern)]muxentry{ handlefunc, pattern })里面, 查找的时候, 遍历字典, 不支持动态路由(若要设置动态路由，仅能将静态路由最后一个字符设置为斜杠, 且自行解析参数), 并匹配最长路径(即动态路由的情况下匹配最长的一个路由, 故每次需要遍历字典，故性能慢).无法按方法分发
  - httpRouter: 相对标准库多支持了动态路由及按方法分发, 路由信息的存储结构是树状结构, 每个节点保留了其子节点的路由信息, 通过循环查找, 找到匹配(精准匹配)的遍便直接返回，故性能高于标准库(beego慢在同是树状结构未保存子节点路由信息，且使用递归遍历)

## 关于redis

### (redis)redis为何被设计成单线程
- [直接结论](https://blog.csdn.net/qqqqq1993qqqqq/article/details/77538202): 因为CPU不是Redis瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（官方FAQ）单线程容易实现, 且CPU也不能逾越网络io瓶颈，故使用单线程

## 关于微服务

### (微服务)golang有哪些rpc框架
- [直接结论](https://scguoi.github.io/DivisionByZero/2016/11/15/GO%E8%AF%AD%E8%A8%80RPC%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94.html): 原生rpc, rpcx, thrift, grpc 性能降序排列，后两个支持跨语言

### (微服务)微服务拆分要根据哪些设计原则, 要做到什么度
- 直接结论:
  - [设计原则](https://juejin.im/entry/59b292e9f265da06633cf89a): AFK原则(按服务功能拆, 水平扩展, 类似数据分区的集群分区), 前后分离(不使用传统模板, 物理分离部署), 无状态(通过其他分布式存储服务存储状态), restful通信风格
  - 拆分粒度: 原则上做到高内聚低耦合, 可以做到独立部署, 且是一个团队可以承载的量, 具体粒度粗细各有优缺点
    - 粒度越细: 扩容缩容更加精准，提高资源利用率, 代码的耦合性减少, 因服务集群化，故单个节点挂掉影响小
    - 粗粒度拆分: 定位问题方便, 服务之间的依赖减少, 监控方便，分布式事务减少

平时是否用context, 简单说下context的理解
go build 编译平时用那些参数
诊断一个服务中较慢的部分
go中的GC算法实现
mysql存储引擎简单说下，用的什么算法
一句sql整个执行流程
表里面有十几个字段, 线上正在运行， 每秒1000插入，此时要扩展一个字段, 此时会发生什么
redis hgetall 时间复杂度
redis hmget 时间复杂度
redis 底层数据结构落地怎么实现
tcp 三次握手
server 出现了很多closewait 过多是什么情况导致的, 如何处理， timewait
redis 使用缓存哪些
redis数据类型
redis使用过程中遇到哪些瓶颈
redis 高可用, 集群版和传统的主从又有什么差异
mysql innodb锁的原则, 什么情况是整张表去锁?
一张超大的表加字段该怎么加
redis 的命令的时间复杂度
golang 实现一个连接池的原理
平时比较关注哪些技术

