# golang-20180720

## 索引
- [(redis)redis为何被设计成单线程?](#redisredis为何被设计成单线程)
- [(golang)关于context包的理解?](#)
- [(golang)为什么gin的路由性能好](#golang为什么gin的路由性能好)
- [(golang)golang的GC算法](#golanggolang的GC算法)
- [(golang)连接池的实现原理](#golang连接池的实现原理)
- [(微服务)golang有哪些rpc框架](#微服务golang有哪些rpc框架)
- [(微服务)微服务拆分要坚持哪些原则, 要做到什么度](#微服务微服务拆分要坚持哪些原则-要做到什么度)
- [(其他)如何诊断一个慢的服务](#其他如何诊断一个慢的服务)

## 关于golang

### (golang)关于context包的理解(用于哪些场景, 用途)
- [直接结论](http://www.nljb.net/default/Golang%E4%B9%8BContext%E7%9A%84%E4%BD%BF%E7%94%A8/): 解决不能从外部杀死停止goroutine(让它自己结束), 是channel＋select的优化版, 解决了一个请多个派生goroutine实现: 有效期，中止线程树，传递请求全局变量。(通常ctx作为第一个参数传入)。
- [详细内容](https://deepzz.com/post/golang-context-package-notes.html): 例如Go实现httServer中，一个请求对应一个goroutine去处理。请求处理函数若启动启动额外goroutine(访问后端服务如数据库和RPC服务)。当一个请求被取消或超时时，所有用来处理该请求的goroutine都应该迅速退出，然后系统才能释放这些goroutine占用的资源
- 相关demo: [各类方法WithValue/Cancel/Timeout/Deadline](/golang/stdpkg/context.go), [实际场景: 监听特定接口到超时为止](/golang/socket/socketServer.go)


### (golang)为什么gin的路由性能好
- 直接结论: 路由块用了httprouter, json序列化用了jsoniter(高性能著称, 貌似from滴滴的工程师). httprouter性能好因为他是自己写的优化，没有用标准库
- [详细内容](http://www.csyangchen.com/go-http-router.html): 为什么httprouter性能好:
  - http.ServeMux: 标准库自带的URL路由, 每个路径注册到一个map(类型是map[string(即pattern)]muxentry{ handlefunc, pattern })里面, 查找时遍历map, 不支持动态路由(若要设置动态路由，仅能将静态路由最后一个字符设置为斜杠故仅支持前一段, 且自行解析参数), 并匹配最长路径(即动态路由的情况下匹配最长的一个路由, 故每次需要遍历字典，故性能慢).无法按方法分发
  - httpRouter: 相对标准库多支持了动态路由及按方法分发, 路由信息的存储结构是树状结构, 每个节点保留了其子节点的路由信息, 通过循环查找, 找到匹配(精准匹配)的遍便直接返回，故性能高于标准库(beego慢在同是树状结构未保存子节点路由信息，且使用递归遍历)

### (golang)golang的GC算法:
- 直接结论: 三色标记算法(1.8rc)
- 前置扩展([详细](http://legendtkl.com/2017/04/28/golang-gc/), [简略](https://lengzzz.com/note/gc-in-golang)): 常见的GC算法:
  - 引用计数(OC, PHP): 每个对象内部维护该对象的引用计数(有指针指向该单元时计数加1, 删除某个指向它的指针时计数减1)，引用计数为0时，自动销毁对象(销毁时其指向的其他对象计数减1)。
    - 优点: 渐进式分摊了gc成本,算法易实现, 堆不用被耗尽到某个阈值前才会触发
    - 缺点: 不能处理循环引用(后来有对应方案，例如强引用), 维护应用计数存在开销，其他: 存放对象的池不是cachefriendly的，容易cache miss影响效率
  - Mark-Sweep法(标记清除法, go<1.3, 1.3时Sweep改为并行操作): 该算法是第一种自动内存管理，基于追踪的垃圾收集算法。很古老(70年代)。变成垃圾未立刻回收，保持不可达状态，当满足时间间隔或堆的阈值。用户程序被系统挂起(STW: StopTheWorld), 从程序(堆)的根节点递归遍历所有能访问到的对象(包括对象指向的对象)并打上标记(Mark)。清除(Sweep)没有被标记的对象
    - 优点: 不用维护引用计数值
    - 缺点: 程序被整个挂起(STW)
  - 三色标记法(Tri-color marking, go1.5 & 1.6): 对象分为三个颜色(颜色代表集合)(白: GC候选对象(待处理); 灰: 不会被GC,但对白对象引用待确认(处理中) 黑色:不存在对白对象的引用(处理完成)
    - 原理:创建集合白、灰、黑。 所有对象为白色。 从根节点开始遍历所有对象(不递归, 故只有第一层对象)，遍历到的对象变为灰色。 再遍历灰对象(并变黑)，将灰对象引用的白对象变灰，重复到灰色中无任何对象 通过write-barrier检测对象有变化，重复以上操作sweep所有白色对象(清除时会stw)
    - 优点: 标记时不会stw
    - 缺点: 垃圾生成速度大于标记速度造成堆积, 且需要其他技术(write-barrier)跟踪对象引用变化
  - 分代收集(jvm .net): 依据：绝大部分对象生命周期都很短。所以按照对象的生命周期长短来进行分代(0, 1, 2)。 新对象放入0代, 当内存用量超过阈值(小)时，触发0代GC, 幸存对象放入1代,当超过阈值(中)时, 触发1代回收, 2代同理
    - 因为0代对象少，每次收集时遍历都很快(较1代快几个数量级)。只有内存消耗过大时才会触发较慢的1代和2代收集。
    - 优点: 分代收集是目前比较好的垃圾回收方式。
    - 缺点: 实现复杂
- [详细内容](http://legendtkl.com/2017/04/28/golang-gc/):
  - 何时触发GC: 在堆上分配大于32K字节对象时检测此时是否触发gc(代码:forceTrigger||memstats.heap\_live>=memstats.gc\_trigger)(强制触发(手动或每隔2分钟)or当前堆上的活跃对象大于初始化时设置的触发阈值: 默认4MB, 每次标记后会动态更新/翻倍)
  - 通过三色标记法进行GC:
    - 开始gc后: 第一次STW, 不符初始化操作, 例如启动write-barrier
    - stack scan: 从root开始遍历(全局和goroutine栈上的指针)。使该些对象变灰(灰色队列GCW每个P都有，全局也有)
    - mark: 遍历灰色对象，其引用对象变灰，自身变黑
    - marktermination: 第二次STW，根据write-barrier重新扫描全局和变变化过的goroutine的栈(1.8开始不扫描goroutine了), 结束标记, 收缩栈
    - sweep: 清除白对象(上锁), 重定义触发阈值

### (golang)连接池的实现原理
- 直接结论: 将连接句柄(什么是句柄: 句柄是个数字(长度和系统位数相同)。是一个对象的唯一Id), 存入channel中，由于缓存chan特性，获取连接时优先返回池中现存连接，若没有，则阻塞或创建新连接，将阻塞或者新建连接（在最大限制数以下）。
- 具体代码: [demo](/golang/points/genericPool.go)
- 额外扩展: 如何池化goroutine,即控制goroutine数量(通过装饰器方式改进WaitGroup，Add行为在超出连接数时被chan阻塞)

## 关于redis

### (redis)redis不同数据类型底层数据结构

### (redis)redis为何被设计成单线程
- [直接结论](https://blog.csdn.net/qqqqq1993qqqqq/article/details/77538202): 因为CPU不是Redis瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（官方FAQ）单线程容易实现, 且CPU也不能逾越网络io瓶颈，故使用单线程

## 关于微服务

### (微服务)golang有哪些rpc框架
- [直接结论](https://scguoi.github.io/DivisionByZero/2016/11/15/GO%E8%AF%AD%E8%A8%80RPC%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94.html): 原生rpc, rpcx, thrift, grpc 性能降序排列，后两个支持跨语言

### (微服务)微服务拆分要根据哪些设计原则, 要做到什么度
- 直接结论:
  - [设计原则](https://juejin.im/entry/59b292e9f265da06633cf89a): AFK原则(按服务功能拆, 水平扩展, 类似数据分区的集群分区), 前后分离(不使用传统模板, 物理分离部署), 无状态(通过其他分布式存储服务存储状态), restful通信风格
  - 拆分粒度: 原则上做到高内聚低耦合, 可以做到独立部署, 且是一个团队可以承载的量, 具体粒度粗细各有优缺点
    - 粒度越细: 扩容缩容更加精准，提高资源利用率, 代码的耦合性减少, 因服务集群化，故单个节点挂掉影响小
    - 粗粒度拆分: 定位问题方便, 服务之间的依赖减少, 监控方便，分布式事务减少

## 关于其他

### (其他)如何诊断一个慢的服务
- 直接结论: 分析排除干扰因素 -> 看elk分析慢服务的场景 -> 日志定位慢方法/函数 -> benchmark test 相应代码, 是否未管理好内存，是否goroutine挤压,是否竞争锁资源，是否没命中缓存
- [详细内容](https://www.zhihu.com/question/36402618):
  - 先分析用户从请求到落地经过环节，排除用户环境问题和网络问题。
  - 从web接入层开始分析，是压力大扛不住用户请求还是代码本身性能不好一直很慢（系统负载，异常日志）
  - 通过在中间件层和依赖服务中记录日志, 定位具体慢方法/函数
  - 排查是因为代码未管理好内存，是否是goroutine积压，是否没命中缓存
- [其他扩展](https://liudanking.com/arch/%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%8B-go-%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/): 容器环境下 go 服务性能诊断方案设计与实现

tcp 三次握手
server 出现了很多closewait 过多是什么情况导致的, 如何处理， [timewait](https://www.cnblogs.com/hjqjk/p/5625848.html)

go build 编译平时用那些参数

[mysql存储引擎简单说下，用的什么算法](https://www.cnblogs.com/fuyunbiyi/p/2429297.html)
一句sql整个执行流程
表里面有十几个字段, 线上正在运行， 每秒1000插入，此时要扩展一个字段, 此时会发生什么
mysql innodb锁的原则, 什么情况是整张表去锁?
一张超大的表加字段该怎么加
关于索引
https://blog.csdn.net/lixingying567/article/details/73505943
https://blog.csdn.net/xupeng874395012/article/details/53390208
https://www.cnblogs.com/wujf/p/9176840.html


redis数据类型
https://blog.csdn.net/zdp072/article/details/50991116
https://blog.csdn.net/ydyang1126/article/details/72667602
https://blog.csdn.net/c295477887/article/details/52487621
redis 底层数据结构落地怎么实现
redis 的命令的时间复杂度 (redis hgetall 时间复杂度 redis hmget 时间复杂度)
redis使用过程中遇到哪些瓶颈
redis 高可用, 集群版和传统的主从又有什么差异
