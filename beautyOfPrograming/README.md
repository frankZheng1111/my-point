# 编程之美章节思路小结

## 索引
- [2.1 求2进制数中1的个数](#21-求2进制数中1的个数)
- [2.2 (1) 求N阶乘中末尾0的数量？ (2) 求N阶乘二进制表示中末尾1的位数](#22-1-求n阶乘中末尾0的数量-2-求n阶乘二进制表示中末尾1的位数)
- [2.3 寻找发帖"水王"(即在一组无序id中找出超过一个出现次数超过50%的id(假设一定存在))](#23-寻找发帖水王即在一组无序id中找出超过一个出现次数超过50的id假设一定存在)
- [2.4 求1 ~ N(给定正整数)，十进制下 1 出现的次数](#24-求1--n给定正整数十进制下-1-出现的次数)

## 2.1 求2进制数中1的个数
- 解法1: 根据短除法十进制转二进制的思路，每除2取余，若余1，则1的个数加1，时间复杂度O(logN)
- 解法2: 基本思路同上，与1作‘与’运算，若大于0，则1的个数加1，然后数字左移一位重复上述步骤，时间复杂度O(logN)
- 解法3: 当给定的数N大于0时，N & (N - 1), 即移除最左侧的一个1， 重复此运算，直到结果等于0，在此之前每做一次该运算，1的个数加1，时间复杂度只与1的个数有关
  - 扩展: 判断给定的数是否是2的整数次幂？ A: 由于2的整数次幂1的个数为1，故解法3可用于此：N >= 0 && (N & (N - 1)) == 0
- 解法4：当给定的整数限制长度的情况下，空间换时间，用一个数组按顺序列出每一个数中1的个数，以给定的数为索引，可直接得出结果，时间复杂度O(1)

## 2.2 (1) 求N阶乘中末尾0的数量？ (2) 求N阶乘二进制表示中末尾1的位数

### 核心思路
将N阶乘的结果进行质因数分解，即结果可以分解为 N! = 2^x * 3^y * 5^z * 7^a * ... * 其他质数的整数幂的积

- 求N阶乘中末尾0的数量取决于可以被10的m次幂整除，只有2 * 5 = 10 即 m = Min(x, z), 由于能被2整除的数远多于5，故其结果基本上等同于 m = z,即 N!后有多少个0取决5的指数。
  - 可用以下公式z = f(1) + f(2) + f(3) + f(4) + ... + f(N), 其中f(x)为能被5整除的次数;
  - 上述公式可以进一步简化: z = (N / 5) + (N / 5^2) + (N / 5^3) + (N / 5^4) + ...(直到 5^k > N), 其中(N / 5)表示1 ~ N中能被5整除的数量，(N / 5^2)表示1 ~ N中被5整除后能再整除一次的数量。。。
  - 举例： 当N = 27时 1 ~ 27中有(27/5=5)个数(即5，10，15，20，25)可以被5整除，其中有(27/25=1)个数可以再被5整除一次故 z = 27/5 + 27/5^2 = 5 + 1 = 6 可以分解出 6个5
- 二进制表示中末尾1的位数等于末尾0的的数量加1, 二进制中末尾每多一个0便可以被2整除一次,即结果为(x + 1)
  - x的解法参照第一个问题:  z = (N / 2) + (N / 2^2) + (N / 2^3) + (N / 2^4) + ...(直到 2^k > N)

## 2.3 寻找发帖"水王"(即在一组无序id中找出超过一个出现次数超过50%的id(假设一定存在))
- 解法1: 排序后遍历集合， 当超过某预定阈值后返回该id, 时间复杂度O(NlogN + N),若阈值为其他值该解法也适用
  - 解法1特例: 当阈值大于50%时，排序后中间的那个Id一定为要找的Id, 时间复杂度O(NlogN)

### 核心思路

在保留集合特征的情况下缩小规模,例如: 移除2个不同的Id, 剩余的集合中某一个Id依旧超过50%, 由于会满足这个特性，当集合长度为2(长度为偶数)或1(长度为奇数)时, 剩余的Id 便是要找的ID

- 解法2: 遍历该集合, 每一次循环取一个值保留，并计数为1，若下一次循环的值不等于保留的值，则清除保留的值(即从集合中移除两个不同的值)，若和保留的值相同，则保留的值得计数为1，需要在接下来的循环中有同等数量与保留值不一样的数字出现才能清除保留的值(即当计数为0的时候，视作移除了n组不同的值), 最后保留的值中的Id便是核心思路中最后剩余的Id
  - 扩展问题: 若一组集合中有3个Id出现次数超过(1/4),找出这三个ID? A：即每次移除4个不同的ID，即解法2保留3个值

## 2.4 求1 ~ N(给定正整数)，十进制下 1 出现的次数
例如: 当N等于12时,1 2 3 4 5 6 7 8 9 10 11 12, 其中1出现了 1(1) + 1(10) + 2(11) + 1(12), 总共5次

- 解法1：遍历1 ~ N, 统计每一个数中1的数量(每一个数除10取余，若余数1为1，则1的出现次数+1，直到该值被除至小于0为止)，时间复杂度O(N * logN)
- 解法2: 找规律?
  - 设 N = abcde 若要统计百位上的1的次数:
  - 若c = 0, 则 出现1的次数为ab * 100(即100 ~ 199, 1100 ~ 1199, 2100 ~ 2199, 3100 ~ 3199 ... a(b-1)100 ~ a(b-1)199)
  - 若c = 1, 则 出现1的次数为ab * 100 + (de + 1)(即上述情况多出ab100 ~ab1de)
  - 若c > 1, 则 出现1的次数为(ab + 1) * 100(即c=0情况多出ab100 ~ab199)

## 2.4.2 上一个问题求出f(N), 求满足条件的N 最大是多少

- 解法: 作假设
  - f(9) = 1
  - f(99) = 20
  - f(999) = 300
  - f(9999) = 4000
  - 5) 导出 f(10^n - 1) = n * 10^(n-1)
  - 当n = 10时，f(10^10 - 1) > 10^10 - 1
  - 假设存在特定值(设为N)的时候, f(n) 恒大于 n
  - 即最大值存在于 1 ~ N之间, 只要从大往小遍历即可
  - 由5)的公式可看出，每增加10, f(n)至少增加1， 每增加100，f(n)至少增加20, 以此类推每增加10^k f(n)增加k * 10^(k-1)
  - f(n) > n => f(0 + a * 10^k + b * 10^(k-1) + c * 10^(k - 2)...) > a * k * 10^(k-1) + b * (k - 1) * 10^(k-2) + .... // 常数a>=1的正整数
  - => 由上式导出 => 当不等式右边 减去 省略项后，不等式依旧成立
  - f(n) > n => f(0 + a * 10^k + b * 10^(k-1) + c * 10^(k - 2)...) > a * k * 10^(k-1) + b * (k - 1) * 10^(k-2)
  - => f(n) > a * k * 10^(k-1) + b * (k - 1) * 10^(k-2)
  - 用类似规则社区n的省略项， n =  a * 10^k + b * 10^(k-1) + c * 10^(k - 2).... < a * 10^k + (b + 1) \* 10^(k-1)
  - => a * 10^k + (b + 1) \* 10^(k-1) > n
  - f(n) > a * k * 10^(k-1) + b * (k - 1) * 10^(k-2) >=  a * 10^k + (b + 1) * 10^(k-1) > n
  - 解当中部分的不等式: k>= 10 + ((b + 11) / (b + 10a)), 由于常数a>=1的正整数, 故((b + 11) / (b + 10a)) < 2, 即k>=12时满足不等式
  - 即当看k = 12时, f(n) > n恒成立, 即f(1 * 10^12) > 1 * 10^12 恒成立, 即上限值为10^12 - 1，由此数往下遍历即可
  - (此处与书p137有出入)
