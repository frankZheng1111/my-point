# 编程之美章节思路小结

## 2.1 求2进制数中1的个数

- 解法1: 根据短除法十进制转二进制的思路，每除2取余，若余1，则1的个数加1，时间复杂度O(logN)

- 解法2: 基本思路同上，与1作‘与’运算，若大于0，则1的个数加1，然后数字左移一位重复上述步骤，时间复杂度O(logN)

- 解法3: 当给定的数N大于0时，N & (N - 1), 即移除最左侧的一个1， 重复此运算，直到结果等于0，在此之前每做一次该运算，1的个数加1，时间复杂度只与1的个数有关

  - 扩展: 判断给定的数是否是2的整数次幂？ A: 由于2的整数次幂1的个数为1，故解法3可用于此：N >= 0 && (N & (N - 1)) == 0

- 解法4：当给定的整数限制长度的情况下，空间换时间，用一个数组按顺序列出每一个数中1的个数，以给定的数为索引，可直接得出结果，时间复杂度O(1)

## 2.2 (1) 求N阶乘中末尾0的数量？ (2) 求N阶乘二进制表示中末尾1的位数

### 核心思路

将N阶乘的结果进行质因数分解，即结果可以分解为 N! = 2^x * 3^y * 5^z * 7^a * ... * 其他质数的整数幂的积

- 求N阶乘中末尾0的数量取决于可以被10的m次幂整除，只有2 * 5 = 10 即 m = Min(x, z), 由于能被2整除的数远多于5，故其结果基本上等同于 m = z,即 N!后有多少个0取决5的指数。

  - 可用以下公式z = f(1) + f(2) + f(3) + f(4) + ... + f(N), 其中f(x)为能被5整除的次数;

  - 上述公式可以进一步简化: z = (N / 5) + (N / 5^2) + (N / 5^3) + (N / 5^4) + ...(直到 5^k > N), 其中(N / 5)表示1 ~ N中能被5整除的数量，(N / 5^2)表示1 ~ N中被5整除后能再整除一次的数量。。。

  - 举例： 当N = 27时 1 ~ 27中有(27/5=5)个数(即5，10，15，20，25)可以被5整除，其中有(27/25=1)个数可以再被5整除一次故 z = 27/5 + 27/5^2 = 5 + 1 = 6 可以分解出 6个5

- 二进制表示中末尾1的位数等于末尾0的的数量加1, 二进制中末尾每多一个0便可以被2整除一次,即结果为(x + 1)

  - x的解法参照第一个问题:  z = (N / 2) + (N / 2^2) + (N / 2^3) + (N / 2^4) + ...(直到 2^k > N)
